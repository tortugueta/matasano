# -*- coding: utf-8 -*-

# The matasano cryptography challeges
# Set 3 / Challenge 17
# The CBC padding oracle

# Imports
import matasanolib
from Crypto.Cipher import AES
import numpy.random as rnd

# Global variables
blocksize = 16
key = matasanolib.random_key(blocksize)

# Define the first function (padding and encryption)
def encrypt():
	"""
	This function selects a random string out of a set of 10, pads it to 16
	characters and encrypts it with an AES key in CBC mode. The key is random
	but always the same. The IV is random and not always the same, but it is
	returned to the caller alongside the generated ciphertext.

	Returns
	-------
	A tuple (iv, ciphertext), where iv is the initialization vector used for
	the encryption.
	"""

	# List of strings. We will select one at random
	str1 = "MDAwMDAwTm93IHRoYXQgdGhlIHBhcnR5IGlzIGp1bXBpbmc="
	str2 = "MDAwMDAxV2l0aCB0aGUgYmFzcyBraWNrZWQgaW4gYW5kIHRoZSBWZWdhJ3MgYX" + \
		"JlIHB1bXBpbic="
	str3 = "MDAwMDAyUXVpY2sgdG8gdGhlIHBvaW50LCB0byB0aGUgcG9pbnQsIG5vIGZ" + \
		"ha2luZw=="
	str4 = "MDAwMDAzQ29va2luZyBNQydzIGxpa2UgYSBwb3VuZCBvZiBiYWNvbg=="
	str5 = "MDAwMDA0QnVybmluZyAnZW0sIGlmIHlvdSBhaW4ndCBxdWljayBhbmQgbmltYmxl"
	str6 = "MDAwMDA1SSBnbyBjcmF6eSB3aGVuIEkgaGVhciBhIGN5bWJhbA=="
	str7 = "MDAwMDA2QW5kIGEgaGlnaCBoYXQgd2l0aCBhIHNvdXBlZCB1cCB0ZW1wbw=="
	str8 = "MDAwMDA3SSdtIG9uIGEgcm9sbCwgaXQncyB0aW1lIHRvIGdvIHNvbG8="
	str9 = "MDAwMDA4b2xsaW4nIGluIG15IGZpdmUgcG9pbnQgb2g="
	str10 = "MDAwMDA5aXRoIG15IHJhZy10b3AgZG93biBzbyBteSBoYWlyIGNhbiBibG93"
	strings = [str1, str2, str3, str4, str5, str6, str7, str8, str9, str10]
	selected = strings[rnd.randint(10)]

	# Decode the base 64 to ascii and add padding
	selected = matasanolib.b64toascii(selected)
	selected = matasanolib.pkcs7padding(selected, blocksize)

	# Generate a random iv and encrypt
	iv = matasanolib.random_key(blocksize)
	cipher = AES.new(key, IV=iv, mode=AES.MODE_CBC)
	ciphertext = cipher.encrypt(selected)

	return (iv, ciphertext)

# Define the second function (decryption and padding check)
def decrypt(ciphertext, iv):
	"""
	This function gets a ciphertext generated by the encrypt function, along
	with the initialization vector used in the encryption. It decrypts the
	ciphertext using the global key and checks the padding. If the padding is
	valid it returns true, otherwise it returns false.

	Parameters
	----------
	ciphertext : a Python string
		A ciphertext generated by the encrypt function
	iv : a Python string
		The initialization vector used in the encryption of ciphertext

	Returns
	-------
	True if the padding of the plaintext is valid, false otherwise.
	"""

	# Generate the cipher and decrypt
	cipher = AES.new(key, IV=iv, mode=AES.MODE_CBC)
	plaintext = cipher.decrypt(ciphertext)

	# Check the padding
	try:
		unpadded = matasanolib.pkcs7padding(plaintext, 0)
		return True
	except TypeError:
		return False


### Begin the main script ###

# Generate a valid ciphertext
iv, ciphertext = encrypt()

# Create the string where we will store the intermediate step
unAES = ""

# Decrypt block by block
ciphertext = matasanolib.BlockString(ciphertext, blocksize)
for index, block in enumerate(ciphertext):
	# Initialize the previous block and the intermediate block
	previous = "\x00" * blocksize
	intermediate = "\x00" * blocksize

	# Start decrypting the block for the last character
	count = 0
	for i in xrange(blocksize-1, -1, -1):
		count += 1

		# We decrypt 'previous + block' with any IV, changing the character 'i'
		# of the previous block until the decryption gives a valid padding.
		for rollingchar in xrange(256):
			previous = list(previous)
			previous[i] = chr(rollingchar)
			previous = "".join(previous)
			currentciph = "".join([previous, block])
			if decrypt(currentciph, iv):
				# Find the intermediate character
				intermediate = list(intermediate)
				intermediate[i] = chr(count ^ rollingchar)
				intermediate = "".join(intermediate)

				# Update previous
				previous = list(previous)
				for j in xrange(i, blocksize):
					previous[j] = chr((count + 1) ^ ord(intermediate[j]))
				previous = "".join(previous)

				break
	unAES = "".join([unAES, intermediate])

# Once we have the intermediate decryption step for each block, we just have to
# xor it against the ciphertext of the previous block.
plaintext = ""
ciphertext = ciphertext.string()
ciphertext = "".join([iv, ciphertext])
ciphertext = matasanolib.BlockString(ciphertext, blocksize)
unAES = matasanolib.BlockString(unAES, blocksize)
for i in xrange(unAES.numblocks()):
	ciphblock = [ord(char) for char in ciphertext[i]]
	unAESblock = [ord(char) for char in unAES[i]]
	plainblock = [chr(ciphblock[j] ^ unAESblock[j]) for j in xrange(blocksize)]
	plainblock = "".join(plainblock)
	plaintext = "".join([plaintext, plainblock])

print plaintext